#!/usr/bin/env python
#=============================================================================
# Copyright (C) 2013 Gregor Larson <gregor.larson@gmail.com>
#
# This file is part of Safemail
#
# Safemail is free software; you can redistribute it and/or modify it under the
# terms of the GNU Lesser General Public License as published by the Free
# Software Foundation; either version 2.1 of the License, or (at your option)
# any later version.
#
# Safemail is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Safemail; if not, see:
#     http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html
#=============================================================================
'''Safemail

@author: Gregor Larson <gregor.larson@gmail.com>
@license: LGPLv2.1
@version: 0.1
'''

from __future__ import print_function
import os,sys,random,cStringIO,email
import email.generator
#import email.mime.text		# not used for now

re_setup_done=False
def setup_re():
   '''Compile module global regular expressions.'''
   if re_setup_done: return

stderr=sys.stderr		# module global stderr
debug_level=None		# module global debug_level

def diagout(*s,**k):
 '''Diagnostic output messages go to stderr by default but
    may be redirected globally, or using parameter.'''
 out="".join([x.__str__() for x in s])

 file=k.get('file')
 if not file: file=stderr	# default to global stderr

 print(out,file=file)
 e=k.get('exception')
 if e: print("   Exception:",e,file=file)
 f=k.get('fatal')
 if f:
    # if debug, print a traceback?
    sys.exit(7)

class sm_exception(Exception):
   '''Top level exception for this script. Optional second arg should
      be underlying exception, if any.'''

   def report(self,note=''):
      '''Report the exception to operator, with optional note appended.'''

      if debug_level:
         exc_type, exc_value, exc_traceback = sys.exc_info()
         # debug output always goes to sys.stderr
         traceback.print_tb(exc_traceback, limit=3, file=sys.stderr)

      if len(self.args) > 1:
         if self.args[1]:
            note=note+"\n   exception:"+self.args[1].__str__()

      t=self._report()
      if note:
         if len(t) + len(note) > 78:
            diagout(t,'\n',note)
         else:
            diagout(t+' '+note)
      else:
         diagout(t)

   def _report(self):
      'should be overridden in subclasses'
      return 'safemail failure '+self.args[0]

class UsageError(sm_exception):
   '''Command was used incorrectly.'''
   def _report(self):
      return "safemail usage error:\n   "+self.args[0]

class MsgBodyFilter:
   '''A message body filter.'''
   def __init__(self,safe,maxlen,allow_digits,allow_html,allow_otp,outstream,note=None):
      self.safe=safe
      self.maxlen=maxlen
      self.remaining=maxlen
      self.allow_digits=allow_digits
      self.allow_html=allow_html
      self.allow_otp=allow_otp
      self.outstream=outstream
      self.set_note(note)

   def out_of_room(self):
      return self.remaining < (self.note_len+20)

   def set_note(self,note):
      '''Suffix note for end of message, if space permits.
      If multiple notes are provided, this will break. Some re-work
      would be required to add or change notes.'''

      self.note=note
      if note:
         # Note is printed with a prefix.
         # Assuming note is final line in message body, we don't need to
         # count newline.
         self.note_len=len(note)+14
      else:
         self.note_len=0
         return

      # The note may not actually be included for short messages

      if self.maxlen > 300:
         # For longer max len, reserve space for the note.
         self.remaining -= self.note_len
      else:
         # For short messages, note may be included if there is
         # sufficient space.
         self.note_len=0

   def add_forward(self,msg):
      '''Add some fields from original message header to the message body.'''
      # In forward mode, some fields from the source message
      # are included in the new message body.
      # No hiding is done on these fields.
      # The amount of detail included depends on the space remaining
      # in the message.
      # print(msg.keys())	#DEBUG
      if self.remaining > 120:
         extra="From: "+msg['from']
         elen=len(extra)+1
         print(extra,file=self.outstream)
         self.remaining -= elen

         if self.remaining > 200:
            extra="To: "+msg['to']
            elen=len(extra)+1
            print(extra,file=self.outstream)
            self.remaining -= elen

            if self.remaining > 360:
               extra="Date: "+msg['date']
               elen=len(extra)+1
               print(extra,file=self.outstream)
               self.remaining -= elen

         print(file=self.outstream)

      # END add_forward

   def add_body(self,payload,comment=None):
      '''Add to outgoing message body given a string payload and optional
      comment for end of section. Leading and trailing blank lines are removed.
      Trailing white-space is removed.'''

      # Could we not simply do payload.split('\n')? Would that be more
      # efficient? Split is not
      # a generator, however, there are some generator implementation of
      # str.split that might be applied....
      # http://stackoverflow.com/questions/3862010/is-there-a-generator-version-of-string-split-in-python/12764478#12764478
      # It would be interesting to try a generator that yields bytearray rather
      # than string.
      # Mind you, cStringIO is likely pretty good, and I believe it is a generator.
      inf=cStringIO.StringIO(payload)

      # TODO: figure out if comment will fit and if it should be included.
      #include_note=False
      #if self.note_len > 0:
      #   # A note was provided
      #   elen=note_len
      #   if self.maxlen > 300:
      #      # For longer max len, include note even if it truncates payload.
      #      self.remaining -= elen
      #      include_note=True
      #   elif len(payload)+elen < x.maxlen:
      #      # For short max len, include note only if there is space.
      #      include_note=True
      #      self.remaining -= elen

      trunc_note=None
      if self.maxlen > 300:
         # longer messages get a truncated indication at the end.
         if len(payload) > self.remaining:
            # add a truncated message to longer messages
            trunc_note='.truncated'
            # reserve space in message for .truncated note
            self.remaining -= 11

      truncated = self.pipe_body(inf)

      if truncated and trunc_note:
         print(trunc_note,file=self.outstream)

      # END add_body

   def close(self):
      '''Complete output.'''

      if self.note_len > 0:
         print("-safemail---",self.note,file=self.outstream)
         # length account for earlier
         self.note_len=0

   def pipe_body(self,instream):
      '''Pipe data into body, update self.remaining.
      Returns False if all input data was handled.
      Returns True if input data was truncated.
      Leading and trailing blank lines are stripped.
      Trailing white space is stripped.
      Output may be sanitized, based on initial flags.'''

      leadin=True
      blank=0
      truncated=False

      w=bytearray()
      # TODO: move to self.trailing_junk or make global
      trailing_junk=bytearray('\n\r\t ')
      for line in instream:
         # line is always str, but we put in bytearry for faster manipulation.
         w[0:]=line
         # remove trailing junk from line
         while w and w[-1] in trailing_junk:	# assumes short-circut eval
            del w[-1]

         if not w:
            # blank line
            if leadin:
               continue		# suppress leading blank lines
            blank += 1		# count blank line
            continue

         leadin=False		# past initial blank lines
         if blank > 0:
            # collapse multiple blank lines to a single blank line.
            print(file=self.outstream)
            self.remaining -= 1
            blank=0

         if self.remaining < 3:
            truncated=True
            break

         if self.safe:
            # Safe mode
            if self.allow_digits or self.allow_otp:
               if not is_safe(w,self.allow_otp,self.allow_html):
                  hidecodes(w)	# hidecodes modifies w bytearray
            else:
               hidecodes(w)	# hidecodes modifies w bytearray

         d=self.remaining - len(w)
         if d < 0:
            # Current line won't fit.
            del w[d:]
            truncated=True

         print(w,file=self.outstream)
         self.remaining -= (len(w)+1)
         if truncated: break

      return truncated
      # END pipe_body

#
# The following several functions deal with trying to figure out
# whether some email contains a code or verification URL that could
# cause damage.
#
# Of course the logic is a bit fuzzy and error-prone, especially for
# non text/plain emails. Use of this logic is optional. It's use is
# controlled by the --digits, --allow and --otp flags on the command-line.
# Without those flags, the following logic will not be used.
#
# For performance reasons I have elected to use the bytearray type to
# hold and pass strings which will manipulated, stripped, and obscured
# in various ways. The bytearry, unlike the str type is mutable and my
# hope is that store management (garbage collection) will be minimized
# by modifying the bytearray in-place.
#
def lens(txt):
   '''Count number of digits, letters, punctuation in some text.
   Returns (digits,lower,upper,punc,late_upper,middle_digits) where
   late_capitals are capital letters that come after lower-case letters
   and middle_digits are digits in the middle of the word (with letters
   before and after).
   The values returned are used for fuzzy entropy logic.
   TODO: create a formal entropy scanner.
   txt is a bytearray, not changed.'''
   digits=0
   lower=0
   upper=0
   late_upper=0		# upper case after lower case
   punc=0		# includes colon and non letters and numbers
   # colon is counted separately because it is not a valid
   # component of a host-name or email address and when it appears
   # in the middle of a word it is more likely be indicate a code
   # of some kind.
   colon=0

   letters=False
   digits_after_letters=0
   middle_digits=0
   for v in txt:
      if v > 125:
         # For now, igore extended ascii and non-printable chars
         continue

      c=chr(v)
      if c <= ' ':
         # ignore white space and control chars.
         continue
      if c < '0':
         punc += 1
      elif c <= '9':
         digits += 1
         if letters: digits_after_letters += 1
      elif c < 'A':
         if c == ':': colon += 1
         punc += 1
      elif c <= 'Z':
         upper += 1
         middle_digits += digits_after_letters
         digits_after_letters=0

         letters=True
         if lower > 0: late_upper += 1
      elif c < 'a':
         punc += 1
      elif c <= 'z':
         lower += 1
         middle_digits += digits_after_letters
         digits_after_letters=0

         letters=True
      else:
         punc += 1

   return (digits,lower,upper,punc,colon,late_upper,middle_digits)

def is_code_log(word):
  if len(word.strip()) == 0: raise UserWarning		#DEBUG
  if word[:4] == '&gt;': raise UserWarning(word)	#DEBUG

def is_code_trace(word,digits,rc):
  '''TODO: use this to create a tool that allows me to inspect
  where in is_code various words are being classified.'''

  return rc

is_code_debug=0
def is_code_log_debug(orig,word,risk):
   if risk >= is_code_debug-1:
      print("is_code(%d): '%s' ::: '%s'" % (risk,word,orig), file=sys.stderr)

if os.environ.has_key('SAFEMAIL_DEBUG_IS_CODE'):
   is_code_debug=int(os.environ['SAFEMAIL_DEBUG_IS_CODE'])

def is_code_wonder(word):
  if is_code_debug:
     print("                                                ?:",word,file=sys.stderr)

# is_code return values indicating what was detected (ordered by risk).
# 0 (False) don't think this is a code (may have digits, but not many)
is_code_SIMPLE=1	# base-10 5+ digits (> codemin)
is_code_NUMBER=2	# base-10 6+ digits (> longmin)
#is_code_URL=3		# a non-complicated URL
is_code_HEX=4		# base-16 32+ bits
is_code_SHORTCODE=5	# base-32 30+ bits, or base-64 36+ bits
is_code_LONGCODE=6	# base-32 40+ bits, or base-64 48+ bits
is_code_LETTERCODE=7	# Some letter code without digits
#is_code_URLCODE=7	# includes a complicated URL with higher entropy (DANGER)

# I would like to consider '/' punctuation, because it is used a lot in
# html, however, it is also used in base64. I have to allow dot comma
# colon semi-colon because they are used to much in english.

leading_punc=bytearray('*<"$(#+=[{'+"' \t\r")
trailing_punc=bytearray('*.?:;,)]}!%>"'+"' \t\r")

def strip_punc(word):
   '''Strip leading/trailing low-entropy punctuation from word.
   word is a bytearray which is modified (consumed) in-place.'''

   if not isinstance(word,bytearray):
      raise TypeError(type(word))	# wrong type, only support bytearray

   if not word: return	# empty
   for _ in range(4):
      # Strip some trailing punctuation that typically would not add
      # any code entropy
      if word[-1] in trailing_punc:
         del word[-1]
         if not word: return	# empty

      # For now, I will consider non-printing and extended ascii chars
      # to be not relevant because if the user can't really see them or
      # type them, they can't disclose much, also, I don't think a URL
      # would work with these.

      if word[-1] < 32 or word[-1] > 125:
         del word[-1]
         if not word: return	# empty

      if word[0] < 32 or word[0] > 125:
         del word[0]
         if not word: return	# empty

      # Strip some leading puctuation that typically would not add
      # any code entropy
      if word[0] in leading_punc:
         del word[0]
         if not word: return	# empty

def strip_cents(word):
   '''Indicate if a string is numeric and ends in dot number number
   such that it might be a price value in many parts of the world, and
   therefor less likely to be a code. Note that any other non-digit char
   will make this false. There is an assumption that any leading or trailing
   punctuation or symbol is stripped prior. word is a bytearray that is
   modified in-place (for performance). True/False is returned to indicate
   if word was modified.'''

   if len(word) < 3:			return False
   if word[-3] != ord('.'):		return False

   if len(word) > 3:
      # check digits before dot
      if not word[:-3].isdigit():	return False

   # check digits after dot
   if not word[-2:].isdigit():		return False

   del word[-3:]	# delete the dot cents
   return True		# return True to indicate modification

# The follow logic strips html chaf from words.
# It could be used with the --allow option to pass
# more html cleanly. In reality, only a fairly simple
# html page will pass the filter. The only way
# I can see to really sanitize the html would be to
# parse it all, find text and URLs and sanitize those
# parts, however, even that would be error-prone I think.

# words that might appear (after stripping punctuation)
# for common prefix, put longer word first.
# Do NOT absorbe URLs here (http: mailto: etc) that may appear
# in text/plain sections.
#
html_prefix=[
 '!--',
 '1px;',
 '6px;',
 '10px;',
 '40px;',
 'a2Column',
 'a3Column',
 'a4Column',
 'align',
 'antialiased',
 'alt=',
 'arial',
 'Arial',
 'bgcolor',
 'block',
 'bold',
 'border-radius',
 'border',
 'campaign',
 'cellspacing',
 'cellpadding',
 'color',
 'colspan',
 'charset',
 'classification',
 'class',
 'display',
 'family',
 'font-family',
 'font-size',
 'font-weight',
 'height',
 'helvetica',
 'Helvetica',
 'href=',
 'http-equiv',
 'id=',
 'isInlineSafe',
 'leftmargin',
 'left',
 'line-height',
 'margin-top',
 'margin',
 'name',
 'none',
 'padding-right',
 'padding',
 'priority',
 'right',
 'sans-serif',
 'src=',
 'style',
 'target',
 'text-align',
 'text-decoration',
 'top_meta',
 'top;',
 'topmargin',
 'title',
 'Transitional',
 'underline',
 'valign',
 '_blank',
 'width',
 ]
html_word_punc=bytearray('=:;>,')

html_suffix=[
 '</a','>Add','</div','</p','</span','<table','</td','text-decoration']

def strip_htmlword(word):
   '''Remove some html words and puntucation.
   word is a bytearray, modified in-place (for performance).
   True/False is returned to indicate if any changes were
   made.'''

   modified=False

   for _ in range(2):
      for prefix in html_prefix:
         if len(word) < 4:	return modified	# empty
         pl=len(prefix)
         if word[:pl] == prefix:
            del word[:pl]
            modified=True
            if not word:	return modified	# empty
            if word[0] in html_word_punc:
               del word[0]
            strip_punc(word)

      for suffix in html_suffix:
         if len(word) < 4:	return modified	# empty
         sl=len(suffix)
         if word[-sl:] == suffix:
            del word[-sl:]
            modified=True
            strip_punc(word)

   return modified

def is_code(word,codemin=4,longmin=5,allow_html=False):
   '''Judge whether a word is a code based on characters it contains.
   In particular, we are looking for numbers
   in base 10, 16, 32 or 64.
   Note that this is normally used with words
   that have leading and trailing punctuation stripped in order to avoid
   false positives. See also strip_punc function.
   word is a bytearray which is consumed (modified) in-place.
   An integer (enum) is returned to provide the risk estimate.'''
   if not isinstance(word,bytearray):
      raise TypeError(type(word))

   # Note: strip_punc must be done by caller prior to first invocation of this
   #       this function, however, we don't do it here because there is some
   #       word-splitting and recursive calls where we don't want it done.

   # if allow_currency?
   cents = strip_cents(word)

   if allow_html:
      htmlword=strip_htmlword(word)
   else:
      htmlword=False

   # Note that some URLs appear in text/plain messages because the are
   # understood by people and machines.

   if word[:7] == 'mailto:':
      mailto=True
      del word[:7]
      strip_punc(word)
      # Splitting of the email address is done below, provided
      # there are not to many digits.
   else:
      mailto=False

   httpurl=False
   if word[:7] == 'http://':
      httpurl=True
      del word[:7]
   elif word[:8] == 'https://':
      httpurl=True
      del word[:8]

   if httpurl:
      sep=word.find('/')
      if sep > 0:
         httpurl_host=word[:sep]	# includes :port
         del word[:sep+1]
         # word now contains what comes after the /

   (digits,lower,upper,punc,colon,lateup,mid_digs)=lens(word)
   letters=lower+upper
   wl=len(word)

   if letters + digits < codemin: return 0		# junk only

   if digits <= codemin and colon==0:
      hyph2=word.split('-')
      if len(hyph2) == 2:
         #print("hyph2-:",hyph2,file=sys.stderr)		#DEBUG
         # exactly 2 parts, recurse
         if is_code(hyph2[0],codemin=codemin-1) == 0:
            if is_code(hyph2[1],codemin=codemin-1) == 0:
               return 0   # let simple 2-part hyphon with almost no digits go

      if colon==0 and ( punc < 6 or mailto ):
         hyph2=word.split('@')
         if len(hyph2) == 2:
            #print("hyph2@:",hyph2,file=sys.stderr)		#DEBUG
            # exactly 2 parts, recurse
            if is_code(hyph2[0],codemin=codemin-1) == 0:
               if is_code(hyph2[1],codemin=codemin-1) == 0:
                  return 0   # let simple 2-part @ email with almost no digits go

      # Few digits
      # In many ways, we should tree this like zero digits.

      # No digits is probably the easiest case, however, the no-digits case
      # is also a problem if we are obscuring codes by zapping digits.
      # For this reason, for zero digits, we should log and figure out
      # if some codes will get past the filter.
      #
      if letters < 9:
         if digits==0 and punc==0:
            # acronyms and abbreviations
            return 0

      if letters < 5:
         # 0-4 letters, plus some digits maybe.
         # short word, could be a date, postal-code etc.
         if digits==0:
            return 0	# punc junk or acronym

         # some digits
         if punc > 1 and lateup > 1:
            return is_code_SHORTCODE
         if punc > 2:
            return is_code_SHORTCODE
         if lateup > 2:
            return is_code_SHORTCODE

         return 0

      if wl < 10:
         # 5-9 chars, may include some digits.

         if lateup > 1:
            # odd capitalization
            if digits==0: is_code_log(word)
            return is_code_SHORTCODE

         if upper > 2 and lower > 2:
            # odd capitalization
            if digits==0: is_code_log(word)
            return is_code_SHORTCODE

         if digits > 0 and upper > 1 and lower > 2:
            # kind of mixed up for a real word
            return is_code_SHORTCODE

         if digits > 0 and lateup > 0:
            # kind of mixed up for a real word
            return is_code_SHORTCODE

         if colon>1 and digits>1:
            return is_code_SHORTCODE

         if punc > 2:
            if digits==0: is_code_log(word)
            return is_code_SHORTCODE

         return 0

      # 10-18 chars. Allow some long words through.
      if digits==0 and lateup==0 and upper<2:
         # just a normal word
         return 0

      if digits==0 and upper<4 and punc==0:
         # CamelCaseJunk
         return 0	# a bit risky, but let it go.

      if digits==0 and lower==0 and punc==0:
         # just an upper-case word
         return 0

      if wl < 14:
         # 10-13 chars. Well, now we have to wonder.
         if lateup > 0 and punc > 1:
            if digits==0: is_code_log(word)
            return is_code_LONGCODE
         if upper > 3 and lower > 3:
            if digits==0: is_code_log(word)
            return is_code_LONGCODE
         if lateup > 3:
            if digits==0: is_code_log(word)
            return is_code_LONGCODE
         if lower == 0 and punc == 0:
            # long upper-case, no hyphons
            if digits==0: is_code_log(word)
            return is_code_LONGCODE

         if digits > 0 and upper > 2 and lower > 3:
            # kind of mixed up for a real word
            return is_code_LONGCODE

         if digits > 0 and lateup > 1:
            # kind of mixed up for a real word
            return is_code_LONGCODE

         if punc > 2 and upper > 2 and lower > 2:
            # kind of mixed up for a real word
            if digits==0: is_code_log(word)
            return is_code_LONGCODE

         if punc > 3 and upper > 1 and lower > 1:
            # kind of mixed up for a real word
            if digits==0: is_code_log(word)
            return is_code_LONGCODE

         if mid_digs > 0:
            return is_code_LONGCODE

         # I wonder what these log words are. Perhaps I could create
         # some automatic white list?
         is_code_wonder(word)
         return 0	# let it go, I guess

      if wl > 18:
         # to long to be a word, could allow for email address I supposed.
         if digits==0: is_code_log(word)

      # 14+ chars seems pretty suspicious (for English)
      # If it had some hyphons, maybe.....
      # We could add a check here to allow non-complicated URL if we
      # wanted to......
      # We could add a check here to allow an email address.

      if upper > 3 and lower > 4:
         if digits == 0: is_code_log(word)
         return is_code_LONGCODE

      if digits > 0 and upper > 1 and lower > 1:
         return is_code_LONGCODE

      if digits > 2 and upper > 2 and lower > 2:
         return is_code_LONGCODE

      if digits > 3:
         return is_code_LONGCODE

      if mid_digs > 1:
         return is_code_LONGCODE

      if punc>0 and punc<3 and lateup==0 and wl<18 and (upper==0 or lower==0):
         is_code_wonder(word)
         return 0	# let it go, could just be a domain or hyphenated

      # Here I could allow for a non-complex URL or email address
      if digits == 0: is_code_log(word)
      return is_code_LONGCODE

   # More digits than allowed (>codemin)
   if digits <= longmin:
      # but not a huge number of digits.
      # So here is where we allow for a phone number, numeric date, especially
      # if the --otp flag is used (which will increase longmin).
      # By returning SIMPLE or NUMBER to that code.

      if letters == 0 and punc < 2:
         return is_code_SIMPLE

      if letters < 3 and lateup==0 and mid_digs==0:
         return is_code_SIMPLE

      if wl < longmin+6:
         # The follow two are probably the risky ones for allowing a code
         # in that is more than a OTP.
         #
         if letters < 4 and punc < 4 and lateup == 0 and mid_digs==0:
            return is_code_NUMBER

         if letters < 6 and punc < 4 and (upper == 0 or lower == 0) and mid_digs==0:
            return is_code_NUMBER

         return is_code_SHORTCODE

      return is_code_LONGCODE

   # Excessive digits (>longmin)
   if letters == 0 and punc < 2:
      return is_code_SHORTCODE

   if letters < 3:
      return is_code_SHORTCODE

   # lots of letters and digits
   return is_code_LONGCODE

   # END is_code

def is_safe(txtline,allow_otp,allow_html):
   '''Analyse a line of text to see if it contains something that may
      be an unsafe code. txtline may be str or bytearray, we don't change it.'''
   if allow_otp:
      longmin=11
      codemin=6
   else:
      longmin=5
      codemin=4

   # For performance, use bytearray.
   # TODO: try a bytearray split generator
   if not isinstance(txtline,bytearray):
      txtline=bytearray(txtline)

   code=0
   orig=bytearray()
   for word in txtline.split():
      if is_code_debug:		orig[0:]=word

      strip_punc(word)
      n = is_code(word,longmin=longmin,allow_html=allow_html)

      if is_code_debug:		is_code_log_debug(orig,word,n)

      # Get the maximum code for the line.
      if n > code: code=n

   #print("is_safe(%d)" % (code),txtline,file=sys.stderr) #DEBUG

   # If the maximum code for the line is to high, we obscure the
   # entire line. For HTML with long lines, this will obscure more
   # than we would like.

   if allow_otp:
      if code > is_code_NUMBER: return False
      return True

   # Not clear if we want to allow SIMPLE
   # If we assume emailed OTP are at least 6 digits, then we are OK, however,
   # if some mechanisms email shorter OTP, then they would get through, in which
   # case we need to reduce longmin or not allow is_code_SIMPLE
   #
   if code > is_code_SIMPLE: return False
   return True

# TODO: create an in-place entropy munger which does the is_safe and
#       word-by-word obscuring all in one pass and uses an external
#	dictionary for common long words... :) like I have time
#	for that. Good luck. This would add the parameters
#	allow_digits, allow_otp, any maybe codemin and longmin also.

def hidecodes(txt):
   '''Obscure the codes in some text. Currently this works simply by
   changing digits, however, that will not work if the code does not
   contain digits. The txt must be a bytearray which is modified in-place.'''

   #
   #	This mechanism, should efficiently handle a high message
   #	volume, such that this code could be used in module form to handle
   #	many messages, rather than a single message per Python invocation.
   #
   #	To this end a bytearray is modified in-place (and returned).
   #

   if not isinstance(txt,bytearray):
      raise TypeError(type(txt))	# wrong type, only support bytearray

   nums=bytearray('0123456789')
   # Instead of simply replacing all the numbers with a constant char
   # I inject some noise to make it a bit harder to attack a base32 or
   # base64 number with few digits.
   #
   noise=bytearray('xXlEOQZSD')

   # TODO: investigate a static seed so the same message will
   #       always hide in exactly the same way. This would prevent an
   #       attack where the same message is provided to the filter several
   #       times in order to discover exactly which characters are digits.
   #
   for (i,v) in enumerate(txt):
     if v in nums:
        txt[i] = random.choice(noise)

   return txt

def output_msgheader(msg,forward_mode,unaddressed,file=sys.stdout):
   '''Output the email header, given an existing message.
   This can be used to compose a single-part message based on content
   from an existing message.  For more sophisticated messages,
   the email module should be used to compose.
   In forward_mode=True, only the Subject header is output, so additional
   information must be provided to the the MTA in order to send this message.
   In relay/redirect mode (forward_mode=False) more message headers
   are output. The Content-type is not included, nor is the destination.
   Depending on the unaddressed flag, the source may also be omitted.
   When passing this message to the MTA, a new destination must be
   provided. Note that the CALLER must output a blank line after
   the message header, prior to the body of the message.'''

   # WARNING: some logic here is duplicated in multipart_full()

   if forward_mode:
      for (k,v) in msg.items():
         # In the forward case, we keep only a few fields necessary to
         # display the content.
         if k.upper()[:7] == "SUBJECT":
            print("%s:" % (k),v,file=file)
         elif k.upper()[:12]=="CONTENT-TYPE":
            print("%s:" % (k),v,file=file)
         elif k.upper()[:4]=="MIME":
            print("%s:" % (k),v,file=file)

      return

   # Problem: forward_mode is omitting some MIME and CONTENT- that is
   # needed when forwarding a single-part text/html message.

   for (k,v) in msg.items():

      # Leave in mime and content
      #if k.upper()[:8]=="CONTENT-": continue
      #if k.upper()[:4]=="MIME": continue

      # It seems to me that most signatures will not be valid either
      # because the message is modified..... The MTA would have to
      # re-sign the message based on the new content, right?
      if k.upper()[:9]=="DOMAINKEY": continue
      if k.upper()[:4]=="DKIM": continue
      if k.upper()[:13]=="AUTHENICATION": continue
      # Message destination is not included because it is assumed that
      # a new destination will be provided when this message is passed
      # to the MTA.
      if k.upper() == "TO": continue
      if k.upper() == "DELIVERED-TO": continue
      if unaddressed:
         # The unaddressed flag omits sender information from the message
         # which might be required to pass certain message relays. If sender
         # information is omitted here, then a new sending address will likely
         # be added by MTA.
         if k.upper() == "FROM": continue
         if k.upper() == "RETURN-PATH": continue
         if k.upper() == "SENDER": continue

      print("%s:" % (k),v,file=file)

   # END output_msgheader

def scantext(msg):
   '''Extract the text/* parts of a multi-part message.
   Returns a list of the text/plain, other text/ parts
   and a count of all the parts.'''
   # TODO: re-consider this design.
   # - how nested are real email messages I would forward as text/plain?
   # - does it really make sense to use walk in the text/plain case, or, should
   #   I only consider top-level text/plain components?
   # - some of this depends on how a mail-client would render a nested multi-part
   #   message with different types of content.
   # - I don't think I can use .walk() to compose a nested multi-part email,
   #   because some structure is missing in the output from .walk()
   # - Does the depth-first order from .walk() really make sense when presenting
   #   a message to the user?
   # - How do popular mail-clients actually present deeply nested  messages
   #   to the user?

   pt=[]
   other=[]
   total=0
   for part in msg.walk():
      total += 1
      ct=part["Content-Type"]
      if ct[:10] == 'text/plain':
         pt.append(part)
      elif ct[:4] == 'text':
         other.append(part)
   return (pt,other,total)

#
# So now we have three different handlers for mail messages.
# - In main() we handle a single-part message (text/plain or text/html).
#   - only a single-part output of type text/plain or text/html is
#     produced.
#
# - In multipart() we handle a multi-part message, but only the text/plain
#   sections, producing a single-part output.
#
# - In multipart_full() we will try and handle text/plain, text/html including
#   nested sections. The multipart_full() function will not apply length
#   restrictions. If there are length restrictions, then the message must
#   be handled by main() or multipart().
#
def multipart_full(msg,opt,file):
   '''Handle a multi-part message, including nesting and text/html/
   Length restrictions may not be handled by this method.'''
   # To create a multi-part nested message there are two options:
   # 1. Walk the incoming message, delete unwanted sections,
   #    sanitize payloads. This approach depends on APIs that allow
   #    in-place modification of message contents.
   # 2. Create a new message, copy headers and relevent sections
   #    from the original message (recursively, sanitizing payloads).

   # Approach 1

   # Iterate through the contents of the message, recursively
   process_parts(msg,opt)

   # When forwarding a multi-part html message, do we insert a
   # text/plain part at the beginning with the forward text?
   # Should I add the forward text to the .preample between
   # the end of the headers and the first multipart boundary?
   # What if there is already a .preamble?
   # It seems text added to preample is not often visible in a mail
   # reader, however, based on the other things I have tried below,
   # I think the best approach for now is to put some diagnostic
   # info in the .epilogue
   #
   # if opt.forward:
   fwd=" From: %s\n To: %s\n Date: %s\n " % (
        msg["from"],msg["to"],msg["date"])
   fwd += " ".join(sys.argv)	#DEBUG
   fwd += "\n"

   if msg.epilogue:
      msg.epilogue=fwd+msg.epilogue
   else:
      msg.epilogue=fwd

   #if msg.preamble:
   #   msg.preamble=fwd+msg.preamble
   #else:
   #   msg.preamble=fwd

   # The following seemed to work to the extent that it allowed me to
   # add a text section to the start or end of the message, however,
   # it did not display properly on the mail clients.
   #	TODO: try adding an HTML section to beginning?
   #
   #	fwdmsg=email.message.Message()
   #	fwdmsg=email.mime.text.MIMEText(fwd)
   #	fwdmsg.set_payload(fwd)
   #
   # If we use .attach, it will be appended to the end of the
   # message, which is not exactly what we want, also, it became
   # the only part visible in some mail readers (thunderbird).
   #
   #	msg.attach(fwdmsg)
   #
   # If we put the text as the first section, it does not appear
   # when viewing, because mail-readers prefer to show the html.
   #
   #	parts=[fwdmsg]+msg.get_payload()
   #	msg.set_payload(parts)

   # Iterate through the message headers
   # TODO: see if it would be better to do this before
   #       process_parts

   # WARNING:  This logic duplicates output_msgheader
   keys=msg.keys()	# modify while iterating....
   for k in keys:
      # Content type field needed.
      if k.upper()[:8]=="CONTENT-":
         continue
      # Not sure if mime needed
      elif k.upper()[:4]=="MIME":
         continue
      elif opt.forward:
         if k.upper()[:7]!="SUBJECT":
            # only the subject is included when forwarding
            del msg[k]

      # It seems to me that most signatures will not be valid either
      # because the message is modified..... The MTA would have to
      # re-sign the message based on the new content, right?
      elif k.upper()[:9]=="DOMAINKEY":
         del msg[k]
      elif k.upper()[:4]=="DKIM":
         del msg[k]
      elif k.upper()[:13]=="AUTHENICATION":
         del msg[k]
      # Message destination is not included because it is assumed that
      # a new destination will be provided when this message is passed
      # to the MTA.
      elif k.upper() == "TO":
         del msg[k]
      elif k.upper() == "DELIVERED-TO":
         del msg[k]
      elif opt.unaddressed:
         # The unaddressed flag omits sender information from the message
         # which might be required to pass certain message relays. If sender
         # information is omitted here, then a new sending address will likely
         # be added by MTA.
         if k.upper() == "FROM":
            del msg[k]
         if k.upper() == "RETURN-PATH":
            del msg[k]
         if k.upper() == "SENDER":
            del msg[k]

   # Should I add a .epilogue with some results from the
   # processing?

   # Write the entire message to the output stream
   # Not sure about performance of as_string() for very large
   # messages. Seems like the correct way to do this is via a
   # generator:
   # https://docs.python.org/2/library/email.generator.html
   #
   gen=email.generator.Generator(file)
   gen.flatten(msg)

   return 0

def process_parts(msg,opt):
   '''Process a multi-part message.
   Nested parts are handled recursively.
   True is returned to indicate that there are still parts
   remaining after processing. False indicates that all the
   parts of a multi-part message were deleted.'''
   # Assign to separate list, because we might be modifying msg while
   # iterating.
   parts = msg.get_payload()
   orig_len=len(parts)
   for i in xrange(len(parts)-1,-1,-1):
      # iterate backwards to allow deletion in-place
      part=parts[i]
      if part.is_multipart():
         # Nested
         if process_parts(part,opt):
            # Some valid sub-parts remain
            continue	# leave part in

         # There is nothing left in this part
         del parts[i]
         continue

      # Not nested
      content = part['Content-type']
      # For now delete anything that is not text
      # Note that this multipart_full is not used for opt.plain
      # so we don't need to check that.
      if content[:5] != 'text/':
         del parts[i]
         continue

      # So, this part will remain.
      if not opt.safe: continue

      # Need to sanitize payload
      payload = part.get_payload(decode=True)
      newpay = cStringIO.StringIO()

      # (safe,maxlen,allow_digits,allow_html,allow_otp,outstream,note)
      mb=MsgBodyFilter(opt.safe,opt.maxlen,opt.digits,opt.allow,opt.otp,newpay)
      mb.add_body(payload)
      mb.close()
      # Now newpay should contain sanitized payload.
      # Question: do I need to fix charset or re-encode, based on the
      # part["Content-Transfer-Encoding"] header?
      # Currently, I see mainly: quoted-printable, 7bit, 8bit, base64
      # It is not clear if set_payload will properly re-encode.
      # https://docs.python.org/2/library/email.mime.html implies that
      # .set_payload can re-encode in some cases.
      # TODO: investigate, do some diffs of before and after.
      # TODO: figure out if long lines will be a problem.
      part.set_payload(newpay.getvalue())

      # end of loop

   if not parts:
      # All parts were deleted
      return False

   # If some parts were removed, need to update the multi-part payload
   # to reflect this.
   if len(parts) != orig_len:
      # TODO: test a bit then try this.
      # msg.set_payload(parts)
      diagout("TBD: Some parts deleted.")

   return True
   # END multipart_html

def multipart(msg,opt,file=sys.stdout):
   '''Handle a multi-part message.
   Takes the message and the command-line options. Note options
   can be any Namespace or object which has the fields we want:
   safe, forward, plain, allow, digits, otp'''

   # Note that I would like to change the semantics of the --allow
   # and --plain slightly, to the following:
   #
   # - Default behaviour is to prefer text/plain and omit text/hmtl if
   #   text/plain is available, but, show text/html if there is no text/plain.
   #   - output could be multi-part if there is no text/plain
   #
   # --plain is to require text/plain and never include text/html
   #   - always output a single-part message.
   #
   # --allow is to transmit both text/plain and text/html and the reader
   #         will decides how to present. When --allow is used, the maxlen
   #         is applied to each section, not the entire message.
   #   - multi-part input will result in multi-part output.

   if opt.allow:
      # To support long messages, including html and nesting,
      # we use the multipart_full() function.
      return multipart_full(msg,opt,file)

   # Walk the parts of the message, get plain, other text and count.
   (plain,other,total) = scantext(msg)

   if len(plain) == 0 and not opt.plain:
      # No text/plain section. But opt.plain not required.
      if len(other) > 0:
         # Use multi-part logic for text/*
         return multipart_full(msg,opt,file)

   # Compose a single-part output message from the text/plain
   # sections, if any. The other sections are ignored.

   # (safe,maxlen,allow_digits,allow_html,allow_otp,outstream,note)
   mb=MsgBodyFilter(opt.safe,opt.maxlen,opt.digits,opt.allow,opt.otp,file)

   output_msgheader(msg,opt.forward,opt.unaddressed,file=file)
   print(file=file)
   note=None

   if len(plain) == 0:
      # no plaintext portion
      mb.set_note("No text/plain in this %d part message" % (total))
      mb.add_body("none")
      rc=3	# no text/plain
   else:
      payload=plain[0].get_payload(decode=True)
      rc=0
      if len(plain) == 1:
         mb.set_note("single text/plain of %d parts" % (total))
         mb.add_body(payload)
      else:
         # there are multiple plaintext portions in this message.
         #
         remaining=len(plain)-1
         # currently .set_note must not be called more than once
         mb.set_note("%d text/plain parts omitted." % (remaining))
         mb.add_body(payload)
         for part in plain[1:]:
            # TODO: look into 'comment' after each part.
            payload = part.get_payload(decode=True)
            if len(payload) > mb.remaining:
               rc=2	# truncated
               break
            mb.add_body(payload)
            remaining -= 1
            mb.note="%d text/plain parts omitted." % remaining
         mb.note="no further text/plain parts"

   if opt.forward:
      mb.add_forward(msg)

   mb.add_body(payload)
   mb.close()
   return rc

   # END multipart

# rc from main will be command exit code
# 0 - normal
main_rc_TRUNCATED=2	# Message was to long.
# No content type text/plain, however, there may be
# other text/html output depending on args.
main_rc_NOPLAIN=3
main_rc_NOCONTENT=4	# No content type on message, text/plain assumed.
main_rc_NOTEXT=5	# No text, only the subject line will be used.
main_rc_FAULT=6		# Failure.

# TODO: add handling for sigpipe which can occur when sys.stdout or sys.stderr
#       is a broken pipe.
def main(args):
   import argparse
   parser = argparse.ArgumentParser(description=
	'''Extract safe text/plain from email. A single bank line is output
	between the headers and message body. Extra leading blank lines
	from message body are removed. Extra trailing blank lines from the
	message body are removed. Sequences of more than 2 blank links are
	collapsed to a single blank line. The stdout from this script should
	be passed to a message transport agent (MTA), for example sendmail.''')

   parser.add_argument('--safe','-s',action='store_true', help=
	'''Obscure any codes or URLs in the text.''')

   parser.add_argument('--forward','-f',action='store_true', help=
	'''Operate in forward mode. Most email headers are stripped except
	for a subject line. Some headers (to,from) become part of the message
	body and may be reformated such that they cannot be used by an MTA.
	Because from/to are no longer included in headers, you must provide
	these when this message is passed to the MTA (sendmail).
	If this forward option is NOT included, the filter runs in
	relay/redirect mode in which case most of the headers are retained,
	including the subject, allowing the message to relayed by an MTA.''')

   parser.add_argument('--unaddressed','-u',action='store_true', help=
	'''Omit From/To from message header. The MTA must provide these.''')

   parser.add_argument('--plain','-p',action='store_true', help=
	'''Only allow text/plain content through filter. Note that a
	single-part message with no content type indicated is assumed to be
	text/plain content for historic reasons. The default behaviour is
	to prefer text/plain but allow text/html if no text/plain is in
	the message.''')

   parser.add_argument('--allow','-a',action='store_true', help=
	'''Allow text/html sections along with text/plain sections.
	The html code, after obscure, may be inconsistent.
	Implies --digits, not compatible with --plain''')

   parser.add_argument('--digits','-d',action='store_true', help=
	'''Allow some digit characters through the text filter, as long
	as they don't look like a code. Has no effect without --safe''')

   parser.add_argument('--otp','-o',action='store_true', help=
	'''Allow what might be an OTP or TOTP or HOTP consisting of a string
	of up to 10 digits through the filter.
	You might use this because you actually want to allow an OTP
	through the filter, but, more likely you will use this because you
	are not worried about OTPs in this instance and you want to avoid
	obscuring some dates and phone numbers and you want to allow more
	of the text/html to work. Has no effect without --safe.''')

   parser.add_argument('--maxlen','-m',action='store',type=int,
                       default=300000, help=
	'''Set a maximum length of the output message body.
	Note that with --allow, there may be multiple message sections and
	this limit may not work as expected.''')

   cmdargs=parser.parse_args(args)

   if cmdargs.allow:
      if cmdargs.plain:
         raise UsageError("--allow not compatible with --plain")

      # For now, --allow will imply --digits
      cmdargs.digits=True

   msg=email.message_from_file(sys.stdin)

   # Account for length of subject line
   if msg.has_key('subject'):
      cmdargs.maxlen -= (len(msg['subject'])+10)

   if msg.is_multipart():
      return multipart(msg,cmdargs)

   # Handle a single-part message here.

   contype=msg["Content-Type"]	# None if no content type
   #contype=msg.get_content_type()  # might be better?
   #print("contype:",contype,"maintype:",msg.get_content_maintype())

   # Compose a single-part output message

   # (safe,maxlen,allow_digits,allow_html,allow_otp,outstream,note)
   mb=MsgBodyFilter(cmdargs.safe,cmdargs.maxlen,cmdargs.digits,cmdargs.allow,
                    cmdargs.otp,sys.stdout)

   if contype == None:
      # No content type on message. For historic reasons this is not
      # an error. Older email systems and clients did not use content
      # type. We will assume text/plain, however, we do not add any
      # content type to our outgoing message.
      payload=msg.get_payload(decode=True)
      if isinstance(payload,str):
         output_msgheader(msg,cmdargs.forward,cmdargs.unaddressed)
         print()

         mb.set_note('Unknown content type')
         if cmdargs.forward:
            mb.add_forward(msg)

         mb.add_body(payload)
         mb.close()

         return main_rc_NOCONTENT
      else:
         raise sm_exception("No content type or message playload: "+str(type(payload)))

   if not isinstance(contype,str):
      raise sm_exception("Unknown content type: "+str(type(contype)))

   #print("Content-Type:",type(contype))	#DEBUG
   textcontent=False
   pay1=None
   if contype[:4] == 'text':
      # We decode the payload in order to process it.
      pay1=msg.get_payload(decode=True)
      if contype[:10] == 'text/plain':
         # This is what we like to see.....
         # Compose a single-part message with the text/plain payload.
         output_msgheader(msg,cmdargs.forward,cmdargs.unaddressed)
         if cmdargs.forward:
            mb.add_forward(msg)

         mb.add_body(pay1)
         mb.close()

         return 0
      # Content is text, but not plain. Probably html.
      if cmdargs.plain:
         # Compose a single-part message, with just a note.

         output_msgheader(msg,cmdargs.forward,cmdargs.unaddressed)
         print()
         mb.set_note("no text/plain in message")
         if cmdargs.forward:
            mb.add_forward(msg)
         mb.add_body("none")
      else:
         # Compose a single-part message, with the same content-type
         # as the incoming message.

         output_msgheader(msg,cmdargs.forward,cmdargs.unaddressed)
         print()
         # Not sure it is valid to include non-html stuff
         # so I might have to remove the forward stuff.
         # yahoo webmail seems to render it correctly.
         if cmdargs.forward:
            mb.add_forward(msg)
         mb.add_body(pay1)

      mb.close()
      return main_rc_NOPLAIN

   # This is not text
   # Compose a single-part message, with just a note.
   output_msgheader(msg,cmdargs.forward,cmdargs.unaddressed)
   print()
   mb.set_note("no text in messsage")
   if cmdargs.forward: mb.add_forward(msg)
   mb.add_body("none")
   mb.close()
   return main_rc_NOPLAIN

   # END main

if __name__ == "__main__":
   # TODO: add a module_init function to make unit-testing easier?
   #		- not much of anything to put in it at this point.

   try:
      sys.exit(main(sys.argv[1:]))
   except sm_exception,e:
      e.report()

